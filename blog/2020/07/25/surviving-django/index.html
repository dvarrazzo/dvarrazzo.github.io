<!DOCTYPE html>
<html class="no-js">
  <head>
    <meta charset="utf-8">
    <title>Surviving Django (if you care about databases) &mdash; Daniele Varrazzo</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-158968242-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-158968242-1');
    </script>
    <link rel="shortcut icon" href="img/favicon.png">
    <link rel="stylesheet" href="/css/plugins.css?h=ee14355f">
    <link href='https://fonts.googleapis.com/css?family=Oswald:400,700,300%7cPoppins:400,300,500,700,600' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/css/main.css?h=af85dcae">
    <link rel="stylesheet" href="/css/syntax.css?h=8242465b">
    <link rel="stylesheet" href="/css/custom.css?h=0cc8bf61">
    <script src="/js/lib/modernizr-2.6.2.min.js?h=d0696412"></script>
  </head>

  <body>
    <div class="main-wrapper">
<header id="header" class="">
  <a href="/about/" class="logo">
    <img src="/img/logo.png?h=0ad960b2" class="logo-dark" alt="">
    <img src="/img/logo-light.png?h=cb66caa4" class="logo-light" alt="">
  </a>
  <a href="#" class="mob-menu"><i class="fa fa-bars"></i></a>
  <nav>
    <ul class="main-menu">
<li>
  <a href="/about/">About</a>
</li>
<li>
  <a href="/software/">Software</a>
  <ul>
<li>
  <a href="https://www.psycopg.org/" target="_blank">psycopg <i class="fa fa-external-link" aria-hidden="true"></i></a>
</li>
<li>
  <a href="https://www.varrazzo.com/pgmp/" target="_blank">pgmp <i class="fa fa-external-link" aria-hidden="true"></i></a>
</li>
<li>
  <a href="https://pgxn.github.io/pgxnclient/" target="_blank">PGXN Client <i class="fa fa-external-link" aria-hidden="true"></i></a>
</li>
<li>
  <a href="https://reorg.github.io/pg_repack/" target="_blank">pg_repack <i class="fa fa-external-link" aria-hidden="true"></i></a>
</li>
  </ul>
</li>
<li>
  <a href="/photo/">Photography</a>
  <ul>
<li>
  <a href="/photo/longexp/">Long exposures</a>
</li>
<li>
  <a href="/photo/ireland/">Ireland, 2019</a>
</li>
<li>
  <a href="/photo/japan/">Japan, 2019</a>
</li>
<li>
  <a href="/photo/whangarei/">Isolation diaries</a>
</li>
  </ul>
</li>
<li>
  <a href="/blog/">Blog</a>
</li>
<li>
  <a href="/contact/">Contact</a>
</li>
    </ul>
  </nav>
</header>
<div class="container fullwidth pt140 pb140" data-background="/img/blog/straws.jpg?h=46f370ae">
  <div class="pt140 pb140">
    <div class="entrance">
      <h2 class="title">Surviving Django (if you care about databases)</h2>
      <p class="separator"></p>
      <p class="small capitalize serif">2020-07-25</p>
      
        <div class="bumper">
          <p class="small">
          
            <a href="/blog/tag/software/">#software</a>
          
            <a href="/blog/tag/development/">#development</a>
          
            <a href="/blog/tag/database/">#database</a>
          
          </p>
        </div>
      
    </div>
  </div>
</div>

<div class="container mt70 mb70">
  <div class="row">
    <div id="content" class="col-md-9"><p>Django is currently the most used full-stack web framework for Python. It has
been around for a good 15 years, emerging as a winner from a period in which
Python was already mature but its web development tools were relatively
immature and fragmented.</p>
<p>Django allows to define the objects in your program as &quot;models&quot;, using the
<tt class="docutils literal">Model</tt> base class: they behave largely like normal Python classes but with
added support for saving and retrieval into the relational database backing
your application. If you don't need this database support, well, you didn't
need a full-stack web framework in first place.</p>
<p>Django tries to be independent from the database you choose. It sounds like
good idea, until it stays on paper, but after working several years with
Django systems, both written from scratch or inherited and to maintain, I am
feeling more and more that the &quot;blessed&quot; way of working with databases and
Django leads to using your database in a sub-optimal way, and to complicate
unnecessarily the maintenance of your projects.</p>
<p>I think the divergence between wishful thinking and reality starts from a
fundamental misunderstanding between you and Django, which is not written in
the contract you have never signed anyway:</p>
<blockquote class="pull-quote">
&quot;independence from the relational database&quot; is a feature of Django as a
framework, <em>not of the program you are writing</em>.</blockquote>
<p>Django needs it, because a web framework not tied to a single database vendor
is more valuable than one tied to a specific one, fair enough. But <em>you
don't:</em> your web program, most likely than not, will not have to switch from
one DB to the other. So, <em>You Ain't Gonna Need Itâ„¢</em>. Portability at all costs
leads to at least two problems:</p>
<p>1) you will not able to use all the features offered by your relational
database, and</p>
<p>2) every change to your models, or to your database schema, is will be more
complicated that it should be.</p>
<div class="section" id="you-ain-t-gonna-need-it">
<h3>You ain't gonna need it</h3>
<p>How many times you have worked to a project and, after 1-2 years of
development, you have changed database to a different one?</p>
<p>I can tell you how many times it happened to me, I counted them: exaclty
never.</p>
<p>Replacing your database vendor is a major, traumatic occurrence, almost as
much as rewriting your program in a different language. If you replace your
database, more likely than not, it is because you are interested to the
features of the new database, you need to use them, so using the common
functionalities between the old and the new one will not solve any of your
problems.</p>
<p>Did you maybe start your project with SQLite, and now your project grew enough
that you need a bigger database? If so then you are still at the phase in
which your project is a toy, you haven't done anything yet that requires
thinking in terms of concurrency. Even if you have to rewrite a few things
it's not going to be a lot.</p>
<p>Do you have a large MySQL project and you have to migrate to PostgreSQL?
That's not gonna happen: you have probably tweaked MySQL, have expertise in
MySQL; maybe PostgreSQL is a better database in some aspects, but not so much
that you want to migrate all your data and start from scratch with the
<a class="reference external" href="http://www.catb.org/jargon/html/F/frobnicate.html">frobbing, twiddling, tweaking</a> the database configuration. Did you say
you have High Availability and Disaster Recovery configured? Are you going to
migrate it too?</p>
<p>In the above paragraph, replace the database vendor with all the permutations
of MySQL, PostgreSQL, MS SQL, Oracle. <em>That's not gonna happen</em>. Except maybe
if an Oracle salesman gets hold of someone in your project with a modicum of
decision making and talks them into buying some sort of expensive license, but
that's not a technical problem, it's a political one. If you care about
technical matters you will start looking for a new job the afternoon of the
day the &quot;Migrate DB to Oracle&quot; ticket hits your issues tracker.</p>
<p>Have you got PostgreSQL in production but you want to test with SQLite because
it's an easier to set up? If so your tests are just a tick-box exercise, you
are not testing anything remotely plausible and resembling your live system.</p>
<p>Choosing a database happens in the first days of your projects, it will not
happen when the project is mature. You may as well use all the features
available with your database, not only the ones common enough that Django
created a Python wrapper for it.</p>
</div>
<div class="section" id="use-all-teh-features">
<h3>Use all teh features</h3>
<p>Scanning the schema of a Django program I've written and maintained for a few
years I see:</p>
<ul class="simple">
<li>schemas (as in the &quot;directory of the tables&quot;, not all the other meanings)</li>
<li>custom domains</li>
<li>collations</li>
<li>triggers</li>
<li>permissions</li>
<li>partial indexes</li>
<li>constraint exclusions</li>
<li>views</li>
<li>stored procedures</li>
<li>partitioned tables</li>
</ul>
<p>If these features were used it's because they allowed to implement in a
simpler way certain features that were needed for the program. Audit for
instance: Django doesn't have an audit feature except for the changes made in
the admin. Even if you added some form of manual auditing to each <tt class="docutils literal">save()</tt>
method, it will not capture changes made outside Django. It wouldn't be very
secure either: Django uses a single user to access the database, so if someone
manages to hijack that user they would be able to change data in the database
and alter the audit tables to hide their traces.</p>
<p>In PostgreSQL you can:</p>
<ul class="simple">
<li>Create an &quot;audit&quot; user: it will have different permissions than the user of
the Django application.</li>
<li>Create an &quot;audit&quot; schema, revoking write permission to all the objects it
will contain from the Django user.</li>
<li>Create a function to append a record to an audit table, owned by the &quot;audit&quot;
user but callable by the Django user.</li>
<li>Add a trigger to the tables to audit.</li>
</ul>
<p>This setup requires Postgres-specific knowledge, which is fair for a feature
that has to watch over the database: for instance you can <a class="reference external" href="https://github.com/dvarrazzo/pgaudit">use an extension</a> to automate the creation and
maintenance of the audit triggers and functions.</p>
</div>
<div class="section" id="so-where-do-i-put-the-schema">
<h3>So where do I put the schema?</h3>
<p>Into a SQL file!</p>
<p>Like, with its tiny <tt class="docutils literal">.sql</tt> extension!</p>
<p>And with comments! Explaining you why a certain index or constraint exist!</p>
<p>With constraints named meaningfully, not
<tt class="docutils literal">auth_group_permissions_group_id_b120cbf9_fk_auth_group_id</tt>.</p>
<p>Sounds civilised to me.</p>
<p>The nice thing of it is that, if you do things carefully enough, Django will
not notice anything at all.</p>
<p>Take the above audit examples: Django is not meant to interact with it:
everything will just happen under its nose. You can use views instead of
tables for read-only models, you can use domains instead of more basic data
types for your fields. Django won't see your triggers triggering, your
constraints constraining, your permissions permitting... Except when things go
wrong, which will result in a Python traceback, ugly, but better than bad data
in the database. And it won't see your procedures proceeding, your domains
dominating... you get the idea.</p>
</div>
<div class="section" id="migrations">
<h3>Migrations</h3>
<p>Django has an amazingly complex system to <a class="reference external" href="https://docs.djangoproject.com/en/3.0/topics/migrations/">perform model migrations</a>. It is
complex because:</p>
<ul>
<li><p class="first">it actually migrates <em>models</em> not <em>schemas</em>. If you change a field's help
text it need a migration. That's not useful at all for the database but
Django will create it for you, and if you remove it, it will add it back.
Changing a <a class="reference external" href="https://docs.djangoproject.com/en/3.0/ref/models/fields/#choices">choices list</a> results in a migration with no database
operation, only Python operation, and practically no purpose.</p>
</li>
<li><p class="first">It allows to access the state of the model at times intermediate between
migrations, using <tt class="docutils literal">get_model(appname, modelname)</tt> and write some Python
code with the returned model. But if that code also happens to use any code
inside your application, likely importing models with a normal Python
<tt class="docutils literal">import</tt> things will crash. But not immediately: only later, when you will
apply some unrelated migration. And not when that migration is needed: only
after it has already been applied and it doesn't have anything more to do in
its lifetime: it is implemented as a model that Django will keep on
importing over and over. In a project I'm currently working I had to add
this function to a module:</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">can_run</span><span class="p">(</span><span class="o">*</span><span class="n">models</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">transaction</span><span class="o">.</span><span class="n">atomic</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
</pre>
<p>And use it whack-a-mole to avoid already applied migrations to explode,
adding early bailouts like:</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">data_migration</span><span class="p">(</span><span class="n">apps</span><span class="p">,</span> <span class="n">schema_editor</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">can_run</span><span class="p">(</span><span class="n">Model1</span><span class="p">,</span> <span class="n">Model2</span><span class="p">,</span> <span class="n">Model3</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="c1"># ...the stuff I meant to do</span>

<span class="k">class</span> <span class="nc">Migration</span><span class="p">(</span><span class="n">migrations</span><span class="o">.</span><span class="n">Migration</span><span class="p">):</span>
    <span class="n">operations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">migrations</span><span class="o">.</span><span class="n">RunPython</span><span class="p">(</span><span class="n">data_migration</span><span class="p">),</span>
    <span class="p">]</span>
</pre>
</li>
<li><p class="first">It detects changes to your models and infer how to change the schema. Except
that not everything always go as expected. In an example my model <tt class="docutils literal">Foo</tt>
needed some extra pepper to its attribute <tt class="docutils literal">bar</tt>. So we thought to fetch
the data from the database into a hidden <tt class="docutils literal">_bar</tt> attribute, and then have a
Python property to expose it. No change needed to the database, but Django
insisted to create migration consisting pretty much in:</p>
<pre class="literal-block">
ALTER TABLE foo DROP COLUMN bar;
ALTER TABLE foo ADD COLUMN bar;
</pre>
<p>and goodbye to your data. But who needs a <tt class="docutils literal">bar</tt>. Well, I could have used a
bar, and a few drinks, if that migration had hit production.</p>
</li>
</ul>
<p>Much of the complexity of this system is designed to give you a specific
feature: migrations abstracted from your database. But in my view, if there is
something less likely to happen than a to write a complex app to run on
interchangeable databases, is the need to repeat the same history of
migrations. The cost you pay for this YAGNI feature is a cumbersome and
fragile system trying to have a life of its own.</p>
<p>I may be a bit of a control freak, but I think that there is too much magic
here, and too few hooks to intervene to correct it, playing too close to my
data to feel comfortable. This comes with the advantage of being able to
replay your migrations in the future on a different database vendor, but I
struggle to find a use case for it not involving parallel universes and time
machines.</p>
</div>
<div class="section" id="so-what-do-i-use-instead-of-migrations">
<h3>So what do I use instead of migrations?</h3>
<p>You can use SQL files! Yes, same extensions as before. It takes some
discipline but it rewards with great control of the behaviour of the database
and the safety of the data. The work involved consist in:</p>
<ul class="simple">
<li>Knowing your database and its data definition and manipulation language, to
know how to change the schema and the data associated.</li>
<li>If you have the database schema in source control, when you change the
schema you will usually want to associate a similar &quot;schema patch&quot;.</li>
<li>You can have a table recording the schema patches applied to the database,
and a script to look for unapplied patches, to run them, and record them on
deployment.</li>
</ul>
<p>I have a <a class="reference external" href="https://gist.github.com/dvarrazzo/86b06961fa3278293e193417adbf3daf">patch_db.py</a> script that I have used, with small variations, in
several projects. It is meant to be executed as a database superuser, so that
the privileges of the application user can be given only reduced privileges.
A few features of this script:</p>
<ul class="simple">
<li>If the database had never been patched, the <tt class="docutils literal">schema_patch</tt> table is
created and all the patches available are registered as already applied.</li>
<li>If the table exists, new files are looked for in the patches directory and,
if not present in the patches table, applied in alphabetical order and
registered. You can use the date as prefix to make sure they are applied in
the correct order.</li>
<li>Only one process at time can run the script: an advisory lock makes sure
that there won't be two concurrent processes both trying to apply the
database patches.</li>
<li>The patching process is identifiable in PostgreSQL via its appname, so it
can be monitored and dealt with in case it gets stuck.</li>
<li>Patches can be applied one by one, with interactive user confirmation, or
unattended for automatic deployment.</li>
<li>You can associate executable scripts to a patch, to run before or after, to
implement procedures difficult to implement in SQL: you can have
<tt class="docutils literal">my_patch.pre.sh</tt> and <tt class="docutils literal">my_patch.post.py</tt> to run respectively before and
after the <tt class="docutils literal">my_patch.sql</tt> is applied, receiving a <tt class="docutils literal">PATCH_DSN</tt> environment
variable to connect to.</li>
</ul>
<p>The script is independent from Django; if used in a Django project it might be
reimplemented as a management command, but I have never felt compelled to do
so.</p>
<p>Once this script is integrated with your deployment procedures, here are a few
examples of patches that can be produced, scanning the patches directory of
projects I have worked with:</p>
<ul class="simple">
<li>Add a field to a table, populate it with data obtained querying other
database tables.</li>
<li>Move a field to another table, split a table into two joined table, change a
relation from one-to-many to many-to-many without losing the current
relations.</li>
<li>Partition a previously unpartitioned data by creating partitions, moving
data into them, and emptying the base table.</li>
<li>Add a new currency to the currencies table, change the name of that Balkan
nation there to &quot;Republic of North Macedonia&quot;, or any other change to some
&quot;configuration table&quot;.</li>
<li>Fix data after a bug producing wrong data was discovered.</li>
<li>Add a new django group and set the group permissions, or add new objects'
permissions to existing groups.</li>
<li>Create a normal column for a piece of data that was previously stored in
unstructured way into a JSON field, remove the data from the JSON and move
it to the new field.</li>
</ul>
<p>In practice, Django migrations create automatically only the simplest of the
operations, like adding a new (empty) column or dropping a column. Renaming a
column is already an operation fraught with perils, and manipulating data
using Python models while the models themselves are being altered is a task of
ShrÃ¶dingeranean effort.</p>
</div>
<div class="section" id="commands-you-don-t-want-to-use">
<h3>Commands you don't want to use</h3>
<p>Once you have introduced your patching script and motivated your team in not
believing in magic, these are a few operation you can do instead of the
&quot;blessed&quot; ways involving Django migrations:</p>
<ul>
<li><p class="first"><tt class="docutils literal">manage.py migrate</tt>: the first time (e.g. new dev setup, unit tests) you
can run <tt class="docutils literal">psql <span class="pre">-f</span> schema/database.sql</tt>. If you do it in a test suite run
you will have tested your schema too. The following times (deployment in
staging and production, distributing changes to other developers) you can
run something similar to the proposed <a class="reference external" href="https://gist.github.com/dvarrazzo/86b06961fa3278293e193417adbf3daf">patch_db.py</a>, and you have tested
the patches too.</p>
</li>
<li><p class="first"><tt class="docutils literal">manage.py makemigrations</tt>: run <tt class="docutils literal">git diff <span class="pre">schema/*.sql</span></tt> and work out
what you have to do, like all the other times you wanted to use the Django
command and it didn't do everything you need.</p>
</li>
<li><p class="first"><tt class="docutils literal">manage.py sqlmigrate</tt>: replaced by <tt class="docutils literal">cat</tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal">manage.py showmigrations</tt>: replaced by <tt class="docutils literal">patch_db.py <span class="pre">--dry-run</span></tt></p>
</li>
<li><p class="first"><tt class="docutils literal">manage.py squashmigrations</tt>... I am in awe of the complexity of
<a class="reference external" href="https://docs.djangoproject.com/en/3.0/topics/migrations/#migration-squashing">squashmigraitons</a>. It reduces your many migrations to an indetermined
number of less migrations, conditioned by the time you have been creative
and have used SQL or Python in them, operations you can mark as &quot;elidable&quot;
if you want to have them dropped, and be careful of
<tt class="docutils literal">CircularDependencyError</tt>, although you can use <tt class="docutils literal"><span class="pre">--no-optimize</span></tt>...</p>
<p>You can replace squashmigrations with <tt class="docutils literal">rm</tt>.</p>
<p>Once the migrations have been applied to all your testing and production
systems and all your developers' databases, just remove them. Or leave them
where they are: who cares. Even if they stay there, even thousand of them
won't do any harm to your program start time: they are not automatically
imported modules. If you want to keep them and not drown in patches you can
divide them by years and change one line to the <tt class="docutils literal">patch_db</tt> script,
whatever.</p>
</li>
</ul>
</div>
<div class="section" id="tips-to-write-a-migration">
<h3>Tips to write a migration</h3>
<p>Writing a complex migration consists in trying the operations to perform in a
testing database and it's often an iterative procedure of trial and error,
with error often destructive and the need of going back to the state before
migrating and remember to add that semicolon.</p>
<p>A way to write a migration patch of the type described here consist roughly
in:</p>
<ul class="simple">
<li>create a file in the <tt class="docutils literal">schema/patches/</tt> directory called
<tt class="docutils literal"><span class="pre">YYYY-MM-DD_some_meaninfgul_description.sql</span></tt>. If you happen to write more
than one patch in the same day and the order matters you can add a <tt class="docutils literal">~02</tt>
to the second patch and so on, as <tt class="docutils literal">~</tt> sorts after <tt class="docutils literal">_</tt>.</li>
<li>Add on top of the file a <tt class="docutils literal">BEGIN;</tt> statement.</li>
<li>Write the statement you think are valid.</li>
<li>Connect to your test database with a psql shell and use <tt class="docutils literal">\i
/path/to/your/patch.sql</tt> to try and apply your patch.</li>
<li>If applying the patch fails, run a <tt class="docutils literal">ROLLBACK</tt> in psql, fix the error, try
<tt class="docutils literal">\i</tt> again.</li>
<li>If applying succeeds, you can explore the database to verify that the
changes applied have produced the right results. You may want to run a
<tt class="docutils literal">SAVEPOINT x</tt> command now: in case you mistype a command while verifying
the results you can run <tt class="docutils literal">ROLLBACK TO SAVEPOINT x</tt> and revert the
transaction to the state just after the patch was applied.</li>
<li>Your patch applied ok, but you don't like the result? <tt class="docutils literal">ROLLBACK</tt>, fix the
patch, try again.</li>
<li>If you are happy of what you see, you can <tt class="docutils literal">ROLLBACK</tt> this psql transaction
and add a <tt class="docutils literal">COMMIT;</tt> to the patch script. You can now apply the patch using
<tt class="docutils literal">patch_db</tt>. If by mistake you commit manually here, you can still run
<tt class="docutils literal">patch_db</tt> and &quot;skip forever&quot; the patch when asked for confirmation.</li>
</ul>
</div>
<div class="section" id="another-random-bit-of-advice">
<h3>Another random bit of advice</h3>
<p>The motivation for writing this article comes from knowledge sharing with the
team I'm currently collaborating, which is using Django the canonical way and
I am convinced they can use the tools they have better. Let's see if they get
convinced to drop Django migrations...</p>
<p>As I'm doing this brain dump, there is another trick that I feel to file under
&quot;know what your tool is doing&quot;: sometimes Django pages get slow because doing
something apparently harmless like accessing a model attribute results in
other queries run. If you do it in a loop it results in a &quot;ripple load&quot;: you
will run 50 queries, each one fetching one record, while you could have run a
single query fetching 50 records, or just a query with an extra JOIN.</p>
<p>How to identify this problem? While you are developing using the development
server, you can log all the operations performed to the database adding this
logger configuration to your <tt class="docutils literal">settings.py</tt>:</p>
<pre class="code python literal-block">
<span class="n">LOGGING</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># ...</span>
    <span class="s1">'loggers'</span><span class="p">:</span> <span class="p">{</span>
        <span class="c1"># ....</span>
        <span class="s1">'django.db'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">'handlers'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'console'</span><span class="p">],</span>
            <span class="s1">'level'</span><span class="p">:</span> <span class="s1">'DEBUG'</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">},</span>
<span class="p">}</span>
</pre>
<p>You will get used to the rhythm of blobs of SQL popping into the log at each
request. But if you introduce by mistake a ripple load it will be very easy to
spot: a fast train of short statement will blaze in the log console. Either it
happens in Python code, or in a template, or as a result of an asynchronous
ajax calls (so not counted in request-oriented tools such as the Django Debug
Toolbar) it will be unmissable; looking at these statements it will be easy to
understand what model caused it and the right <a class="reference external" href="https://docs.djangoproject.com/en/3.0/ref/models/querysets/#select-related">select_related()</a> to add.</p>
<p>You are welcome.</p>
</div>
<div class="section" id="do-you-hate-django">
<h3>Do you hate Django?</h3>
<p>No, I don't, I still like it, although, with Python moving towards asyncio and
<a class="reference external" href="/blog/2020/03/31/first-experience-mypy/">static typing</a>, and with the established
web architecture of a JSON API consumed by a JavaScript front-end, the
appeal for other frameworks such as <a class="reference external" href="https://fastapi.tiangolo.com/">FastAPI</a> is increasing. As opinionated as I am, I
quite like the Django ORM: very simple to use, well integrated with the Python
objects it produces, and it allows to write monsters of nested queries with
great ease.</p>
<p>What I really don't like is when tools get in the way of someone's work.
Sometimes the tools are complex because the problem they try to solve is. But
you are free to ask yourself the question: do I really have that problem? You
might get to the conclusion that no, you don't, and you can make choices to
simplify your life.</p>
<p>In the case of Django, the right economy for me is to use the ORM for querying
and manipulating data, but to avoid using the Models to produce schema, and to
stay well clear of migrations.</p>
</div>

<script src="https://utteranc.es/client.js"
  repo="dvarrazzo/www.varrazzo.com"
  issue-term="pathname"
  label="comments"
  theme="github-light"
  crossorigin="anonymous"
  async>
</script>
    </div>
    <div id="sidebar" class="col-md-3">
<div class="sidebar-inner">
  <div class="widget-area">
<aside class="widget">
  <h3 class=widget-title>Recent posts</h3>
  <ul>
    <li><a href="/blog/2020/05/19/a-trip-into-optimisation/">A trip into optimisation</a></li>
    <li><a href="/blog/2020/04/26/pinhole-day/">Pinhole Day</a></li>
    <li><a href="/blog/2020/04/15/isolation-diaries/">Isolation Diaries</a></li>
    <li><a href="/blog/2020/03/31/first-experience-mypy/">First Experience with Mypy</a></li>
    <li><a href="/blog/2020/03/26/psycopg3-first-report/">psycopg3: a first report</a></li>
  </ul>
</aside>
<aside class="widget">
  <h3 class=widget-title>Tags</h3>
  <ul>
<li><a href="/blog/tag/database/">#database</a></li>
<li><a href="/blog/tag/design/">#design</a></li>
<li><a href="/blog/tag/development/">#development</a></li>
<li><a href="/blog/tag/life/">#life</a></li>
<li><a href="/blog/tag/news/">#news</a></li>
<li><a href="/blog/tag/photo/">#photo</a></li>
<li><a href="/blog/tag/pinhole/">#pinhole</a></li>
<li><a href="/blog/tag/psycopg/">#psycopg</a></li>
<li><a href="/blog/tag/software/">#software</a></li>
<li><a href="/blog/tag/travel/">#travel</a></li>
<li><a href="/blog/tag/website/">#website</a></li>
  </ul>
</aside>
  </div>
</div>
    </div>
</div>

<footer id="footer" class="">
  <div class="footer-links">
    &copy; 2020. By Daniele Varrazzo. |
    <a target="_blank" href="https://github.com/dvarrazzo/">GitHub</a> |
    <a target="_blank" href="https://www.linkedin.com/in/danielevarrazzo/">LinkedIn</a> |
    <a target="_blank" href="https://www.instagram.com/dvarrazzo/">Instagram</a> |
    <a target="_blank" href="https://www.flickr.com/photos/dvarrazzo/">Flickr</a>
  </div>

</footer>
    </div>
    <script src="/js/lib/jquery.min.js?h=d6c1f419"></script>
    <script src="/js/lib/scripts.js?h=e59b43e0"></script>
    <script src="/js/main.js?h=4b3e78de"></script>
  </body>
</html>
